#pragma once

namespace Visualizer {

/**************************************************************************************************
 ****************************************** EntityQuery ******************************************
 **************************************************************************************************/

template <typename... Ts> requires NoCVRefs<Ts...>&& UniqueTypes<Ts...> EntityQuery& EntityQuery::with()
{
    auto types{ getTypeIds<Ts...>() };
    return with(types);
}

template <typename... Ts> requires NoCVRefs<Ts...>&& UniqueTypes<Ts...> EntityQuery& EntityQuery::without()
{
    auto types{ getTypeIds<Ts...>() };
    return without(types);
}

/**************************************************************************************************
 *************************************** EntityQueryResult ***************************************
 **************************************************************************************************/

template <typename... Ts> requires NoCVRefs<Ts...>&& UniqueTypes<Ts...> bool EntityQueryResult::contains() const
{
    auto types{ getTypeIds<Ts...>() };
    return contains(types);
}

template <typename... Ts>
requires NoCVRefs<Ts...>&& UniqueTypes<Ts...> typename TupleTypeN<std::optional<std::size_t>, sizeof...(Ts)>::type
EntityQueryResult::typeIndex() const
{
    return { typeIndex(getTypeId<Ts>())... };
}

template <typename... Ts>
requires UniqueTypes<Ts...> std::optional<std::tuple<const Entity, Ts*...>> EntityQueryResult::at(std::size_t idx) const
{
    if (!contains<Ts...>()) {
        return std::nullopt;
    }

    auto entityTuple{ at(idx) };
    if (!entityTuple.has_value()) {
        return std::nullopt;
    }

    auto entity{ std::get<0>(*entityTuple) };
    auto components{ std::get<1>(*entityTuple) };

    return std::make_tuple(entity, static_cast<Ts*>(components[*typeIndex(getTypeId<Ts>())])...);
}

template <typename... Ts, typename Fn>
requires UniqueTypes<Ts...>&& std::invocable<Fn, Ts*...> void EntityQueryResult::forEach(Fn&& fn) const
{
    forEach<Ts...>(std::forward<Fn>(fn), std::index_sequence_for<Ts...>{});
}

template <typename... Ts, typename Fn>
requires UniqueTypes<Ts...>&& std::invocable<Fn, Ts*...> void EntityQueryResult::forEachWithEntity(Fn&& fn) const
{
    forEachWithEntity<Ts...>(std::forward<Fn>(fn), std::index_sequence_for<Ts...>{});
}

template <typename... Ts, typename Fn, std::size_t... Is>
requires UniqueTypes<Ts...>&& std::invocable<Fn, Ts*...> void EntityQueryResult::forEach(
    Fn&& fn, std::index_sequence<Is...>) const
{
    for (std::size_t i = 0; i < count(); ++i) {
        auto entityTuple{ at<typename std::remove_cvref_t<Ts>...>(i) };
        std::invoke<Fn, Ts*...>(
            std::forward<Fn>(fn), std::forward<Ts*>(static_cast<Ts*>(std::get<Is + 1>(*entityTuple)))...);
    }
}

template <typename... Ts, typename Fn, std::size_t... Is>
requires UniqueTypes<Ts...>&& std::invocable<Fn, Ts*...> void EntityQueryResult::forEachWithEntity(
    Fn&& fn, std::index_sequence<Is...>) const
{
    for (std::size_t i = 0; i < count(); ++i) {
        auto entityTuple{ at<typename std::remove_cvref_t<Ts>...>(i) };
        std::invoke<Fn, Entity, Ts*...>(std::forward<Fn>(fn), std::forward<Entity>(std::get<0>(*entityTuple)),
            std::forward<Ts*>(static_cast<Ts*>(std::get<Is + 1>(*entityTuple)))...);
    }
}

}
